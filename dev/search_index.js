var documenterSearchIndex = {"docs":
[{"location":"#RichRopes","page":"Home","title":"RichRopes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = RichRopes","category":"page"},{"location":"","page":"Home","title":"Home","text":"RichRopes.jl is a package implementing a rope data structure.  This is one of the classic string data structures used in text editing, with good performance for insertion, deletion, and concatenation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"RichRopes enrich the nodes of the rope by including counts of Chars, lines, and graphemes.  They are immutable, returning a new rope for every operation.  This allows for shared structure, and easy-to-implement undo operations: simply return a previous version of the rope.","category":"page"},{"location":"","page":"Home","title":"Home","text":"RichRopes are natively indexed by Char, not bytes, meaning rope[5:10] will return the fifth through tenth character.  By using StringUnits, codeunits and graphemes may also be used to index and slice efficiently.  Textwidth is not stored in nodes, because this metric is mainly useful for reasonably-short spans such as a single line, but tw units from StringUnits are also supported for RichRope operations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Support for the AbstractString interface is complete as to the basics.  Currently absent are any searching operations, such as findfirst|last or occursin.  We intend to support these for literal strings, unfortunately, regex is currently impractical, since PCRE operates on the C interface, not natively Julian data structures.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [RichRopes]","category":"page"},{"location":"#RichRopes.AbstractRope","page":"Home","title":"RichRopes.AbstractRope","text":"AbstractRope <: AbstractString\n\nSupertype for Rope data structures.\n\n\n\n\n\n","category":"type"},{"location":"#RichRopes.cleave-Tuple{RichRope, UnitRange{<:Integer}}","page":"Home","title":"RichRopes.cleave","text":"cleave(rope::RichRope, range::UnitRange{<:Integer})\n\nReturn two ropes which are the head and tail of rope with range removed.  Range is measured in codepoints.\n\n\n\n\n\n","category":"method"},{"location":"#RichRopes.cleave-Union{Tuple{S}, Tuple{RichRope{S, RichRope{S, T} where T<:Union{Nothing, AbstractRope{S}}}, Integer}} where S","page":"Home","title":"RichRopes.cleave","text":"cleave(rope::RichRope, index::Integer)\n\nReturn two ropes created by splitting rope at index, as indexed by codepoints.\n\n\n\n\n\n","category":"method"},{"location":"#RichRopes.codeunitindex-Union{Tuple{S}, Tuple{RichRope{S, RichRope{S, T} where T<:Union{Nothing, AbstractRope{S}}}, Integer}} where S<:AbstractString","page":"Home","title":"RichRopes.codeunitindex","text":"codeunitindex(rope::RichRope{S,RichRope{S}}, index::Integer) where {S<:AbstractString}\n\nReturns the character index (native index unit of RichRopes) for a given codeunit offset (usual native index for Strings).\n\n\n\n\n\n","category":"method"},{"location":"#RichRopes.compactleaves!-Union{Tuple{Array{RichRope{S, Nothing}, 1}}, Tuple{S}, Tuple{Array{RichRope{S, Nothing}, 1}, Integer}} where S<:AbstractString","page":"Home","title":"RichRopes.compactleaves!","text":"compactleaves!(leaves::Vector{RichRope{<:AbstractString,Nothing}}, leafsize=leaf_size[])\n\nCompact a Vector of RichRope leaves, such that the returned Vector contains leaves of approximately leafsize.\n\nNote: this will never make a leaf smaller through splitting, so it cannot be used to reduce the leaf size of a RichRope.  Presuming that the rope was created originally of leaf_size[] leaves, the leaves resulting from compactleaves! will never be larger than 1.75X leaf_size[].\n\nThis is called by rebuild.\n\n\n\n\n\n","category":"method"},{"location":"#RichRopes.delete-Tuple{RichRope, Integer, Integer}","page":"Home","title":"RichRopes.delete","text":"delete(rope::RichRope, index::Integer, n::Integer)\n\nReturn a rope with n characters removed, beginning with the character at index.\n\n\n\n\n\n","category":"method"},{"location":"#RichRopes.delete-Tuple{RichRope, UnitRange{<:Integer}}","page":"Home","title":"RichRopes.delete","text":"delete(rope::RichRope, range::UnitRange{<:Integer})\n\nReturn a rope with the characters in range deleted.\n\n\n\n\n\n","category":"method"},{"location":"#RichRopes.grapheme-Union{Tuple{S}, Tuple{RichRope{S, RichRope{S, T} where T<:Union{Nothing, AbstractRope{S}}}, Integer}} where S<:AbstractString","page":"Home","title":"RichRopes.grapheme","text":"grapheme(rope::RichRope{S,RichRope{S}}, index::Integer) where {S<:AbstractString}\n\nReturn the indexth grapheme of the rope.\n\n\n\n\n\n","category":"method"},{"location":"#RichRopes.graphemeindex-Union{Tuple{S}, Tuple{RichRope{S, RichRope{S, T} where T<:Union{Nothing, AbstractRope{S}}}, Integer}} where S<:AbstractString","page":"Home","title":"RichRopes.graphemeindex","text":"graphemeindex(rope::RichRope{S,RichRope{S}}, index::Integer) where {S<:AbstractString}\n\nReturn the native (character) index of the indexth grapheme.\n\n\n\n\n\n","category":"method"},{"location":"#RichRopes.rebuild","page":"Home","title":"RichRopes.rebuild","text":"rebuild(rope::RichRope{S,RichRope{S}} where {S}, leafsize::Integer=leaf_size[])\n\nRebuild a RichRope.  This will compact adjacent small leaves into correctly-sized ones, and balance the tree.  Note that a value of leafsize smaller than that used to create the rope will not result in any leaf nodes being split, but will affect the target length of leaves which are compacted (see compactleaves!).\n\n\n\n\n\n","category":"function"},{"location":"#RichRopes.splice-Tuple{RichRope, Union{Integer, UnitRange{<:Integer}}, AbstractString}","page":"Home","title":"RichRopes.splice","text":"splice(rope::RichRope, at::Union{Integer,UnitRange{<:Integer}}, str::AbstractString)\n\nReturn a new rope with str spliced into rope. If at is an Integer, the rope is split at at, if at is a range, that range is removed.\n\nExample\n\njulia> String(splice(RichRope(\"aabbcc\"), 3:4, \"!!\"))\n\"aa!!cc\"\n\njulia> String(splice(RichRope(\"aabbcc\"), 3, \"!!\"))\n\"aab!!bcc\"\n\n\n\n\n\n","category":"method"}]
}
